\chapter{Kotlin}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}                  %mette i numeri arabi
\section{Storia}                 %crea la sezione

Kotlin \'e un linguaggio di programmazione open-source \footnote{https://github.com/JetBrains/kotlin}, con la caratteristica di essere orientato agli oggetti, staticamente tipizzato  e basato sulla JVM ( Java Virtual Machine).\\
Lo sviluppo di Kotlin \'e iniziato nel 2010 dall'azienda JetBrains, conosciuta nel modo dello sviluppo software per la realizzazione di diversi IDE ( Integrated development environment ), tra cui: Intellij IDEA,, sul quale si basa l'attuale IDE ufficiale di Google dedicato alla programmazione Android, chiamato: Android Studio.Java \'e sempre stato, negli ultimi anni, uno dei linguaggii  pi\'u usati e conosciuti ma presenta diverse imperfezioni e problemi che spinse il team di JetBrains a iniziare lo sviluppo di un suo linguaggio di programmazione che prendesse in considerazione alcuni spunti e idee introdotte da linguaggi preesistenti come CSharp, Scala, Groovy, ECMAScript, Go, Python.\\
Nel 2015 Google prese in considerazione l'utilizzo di Kotlin come plugin per Android-Studio, e dopo vari test nel 2017  durante la conferenza Google IO ( 2017 ), arriv\'o l'annuncio che uficcializzava Kotlin come nuovo linguaggio di programmazione per lo sviluppo di applicazioni Android, senza escludere e rinunciare a Java, su cui si basa attualmente l'SDK di Android.


\section{Caratteristiche}
Il linguaggio Kotlin \'e stato sviluppato per risolvere molti problemi tipici che riscontrano spesso programmatori Java, infatto  \'e stato progettato e progressivamente testato per 7 anni come versione "beta" dagli stessi programmatori che lavoravano presso JetBrains, fino a raggiungere nel 2017 la versione stabile, \'e nato quindi all'interno di un team di sviluppatori che hanno cercato di risolvere i loro stessi problemi e non in ambito di ricerca come spesso accade.\\
Kotlin prendendo spunto dalle problematiche di Java e da buone regole introdotte da alcuni linguaggi imperativi e funzionali \'e stato modellato in modo tale da aggiungere funzionalit\'a utili sia a livello sintattico che a livello prestazionale, offrendo quindi al programmatore strumenti, caratteristiche e implementazioni semplici e utili ma molto potenti.\\
Un altro aspetto importante su cui il team di Kotlin ha prestato molta attenzione è stata la cura e la buona integrazione del suo plugin con Android Studio. Il supporto dato dal plugin \'e quello di aiutare in ogni momento lo sviluppatore, consigliando tecniche di buona programmazione, abbreviazione del codice per rendere il tutto pi\'u coinciso, conversione automatica del codice Java in Kotlin e ove possibile cercher\'a di allertare lo sviluppatore su possibili errori e problemi di prestazione e sintattici.
Le caratteristiche pi\'u importanti offerte da Kotlin sono l'interoperabilit\'a con Java, permettendo l'utilizzo di librerie Java e Kotlin simultaneamente, l'introduzione di alcune caratteristiche dei linguaggi di ordine superiore, la tipizzazione statica delle variabili, l'inferenza di tipo e soprattutto il null-safety permettendo di differenziare il tipo nullabile e il tipo non-nullabile, prevenendo quindi errori di null pointer expetions.\\
Il codice prodotto in Kotlin \`e inoltre pi\'u compatto, coninciso e meno verboso grazie alle dataclass, il supporto delle lambda function e altri costrutti.





%https://superkotlin.com/why-kotlin-is-the-best-language-for-android-development/
\subsection{Interoperabilit\'a}
I linguaggi Kotlin e Java sono fortemente intercompatibili permettendo quindi a entrambi i linguaggi di coesistere all'interno dello stesso codice e di richimare funzioni e parti di codice in Java da Kotlin e viceversa, poich\'e entrambi i linguaggi producono Java Bytecode.\\
%http://kotlinlang.org/docs/reference/java-interop.html
Prendiamo in considerazione il classico esempio "Hello word" scritto in Kotlin e in Java

\begin{lstlisting}[language=java,caption={Hello.kt in Kotlin}]
package demo
fun main(args : Array<String>) {
  println("Hello, world!")
}
\end{lstlisting}

\begin{lstlisting}[language=java,caption={Hello.java in Java}]

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
\end{lstlisting}

Il compilatore di Kotlin prendendo come input il file "Hello.kt" produrr\'a un JAR eseguibile da Java "Hello.jar"


\begin{lstlisting}[language=bash,caption={Compilatore kotlin}]
$ kotlinc Hello.kt -include-runtime -d Hello.jar //
$ java -jar Hello.jar
$ Hello, world!
\end{lstlisting}

 -includeruntime \'e un opzione del compilatore per produrre un eseguibile jar, includendo le runtime di Kotlin (~800Kb)
% Il compilatore di Kotlin permette inoltre di generare il java bytecode
% \begin{lstlisting}[language=bash,caption={Compilatore kotlin per generare Hello.class}]
% $ kotlinc HelloWorld.kt
% $ javap -c Hello.class
% \end{lstlisting}
%
% Confrontando
% \begin{lstlisting}[language=java,caption={Java Bitecode generato da Kotlin}]
%
% public final class demo.HelloKt {
%   public static final void main(java.lang.String[]);
%     Code:
%        0: aload_0
%        1: ldc           #9                  // String args
%        3: invokestatic  #15                 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V
%        6: ldc           #17                 // String Hello, world!
%        8: astore_1
%        9: getstatic     #23                 // Field java/lang/System.out:Ljava/io/PrintStream;
%       12: aload_1
%       13: invokevirtual #29                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
%       16: return
% }
%
% \end{lstlisting}


% \begin{lstlisting}[language=java,caption={Java Bitecode generato da Kotlin}]
%
% class Hello {
%   Hello();
%     Code:
%        0: aload_0
%        1: invokespecial #1                  // Method java/lang/Object."<init>":()V
%        4: return
%
%   public static void main(java.lang.String[]);
%     Code:
%        0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
%        3: ldc           #3                  // String Hello, world!
%        5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
%        8: return
% }
%
%
% \end{lstlisting}





\subsection{Variabili}
Java pone due differenze quando si parla di variabili, mette a disposizione i principali tipi primitivi (int, boolean, byte, long, short, float, double, char) e i le loro corrispondenti classi (Int, Boolean, Byte, Long, Short, Float, Double, Char).
Uno dei principali cambiamenti introdotti da Kotlin \'e stato quello di rendere accessibile allo sviluppatore tutte le varibili come se fossero oggetti.\\
%https://docs.oracle.com/javase/1.5.0/docs/guide/language/autoboxing.html
La differenza fra i tipi primitivi e gli oggetti sta nel fatto che i primi indicano solamente il tipo di una variabile, mentre gli oggetti incapsulano il tipo e ne aggiungono funzionalit\'a e metodi aggiuntivi, inoltre il tipo primitivo non pu\'o assumere valore nullo. \\
Kotlin operando ad alto livello, rimuove e astrae le due distinzioni poich\'e di default quando viene inizializzata una nuova variabile, Kotlin la identifica come un oggetto, consentendo allo sviluppatore di utilizzare i metodi aggiuntivi ad esso associati, e solo in fase di compilazione, il compilatore di Kotlin controlla se l'oggetto \'e strettamente necessario o pu\'d essere sostituito dal suo corrispondente tipo primivio.

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
    Tipo & Oggetto & Dimensione \\ \hline
    int & Int & 32 bits\\ \hline
    boolean & Boolean & 1 bits\\ \hline
    byte & Byte & 8 bits\\ \hline
    long & Long & 64 bits\\ \hline
    short & Short & 16 bits\\ \hline
    float & Float & 32 bits\\ \hline
    double & Double & 64 bits\\ \hline
    char & Char & 16 bits\\ \hline

    \end{tabular}
\end{center}

Le variabili in Kotlin sono pressocch\'e le stesse che sono presenti in Java, con la particolari\'a che Kotlin cerca di evitare alcuni problemi dovuti a referenze a puntatori nulli ( NullPointerException ). \\
Kotlin richiede che una variabile a cui assegnamo un valore nullo sia dichiarata con l'operatore "?", in caso contrario mostrera un errore in fase di compilazione

\begin{lstlisting}[language=java,caption={Esempio}]
var esempio1: String? = null //corretto
var esempio2: String = null //errore
\end{lstlisting}

Il safe call operator "?" serve ad indicare che la variabile pu\'o assumere in qualsiasi momento un valore nullo, e lascia al programmatore la responsabilit\'a e la possibilit\'a di accederci ugualmente per leggerne il valore, con l'utilizzo dell operatore "!!"",


\begin{lstlisting}[language=java,caption={Esempio !!}]
val nome = getName()!!
\end{lstlisting}

in altrnativa attraverso il Smart Casting offerto da Kotlin l'operatore "!!" si pu\'o omettere, poich\'e il compilatore capisce automaticamente che la variabile non potr\'a essere essere nulla.

\begin{lstlisting}[language=java,caption={Smart Casting}]
fun getName(): String? {..}

val name = getName()
if (name != null) {
  println(name.length)
}

//forma contratta
println(name?.length)
\end{lstlisting}

Un'ultima caratteristica introdotta da Kotlin nell'utilizzo e gestione delle variabili sono  "Lazy  Initialization " e "Late Initialization", due nuovi modi per inizializzre una variabile.
\begin{itemize}                         %crea un elenco puntato
\item Lazy consente di delegare ad una funzione l'inizializzazione della variabile, il risultato della funzione verr\'a assegnato alla variabile, in seguito quando verr\'a effettuato l'accesso alla variabile la funzione non sar\'a rieseguita ma verr\'a solamente passato il valore
\item Late permette di posticipare l'inizializzazione di una variabile, se si tenter\'a di acceddere alla variabile prima che essa venga inizializzata si ricever\'a un errore. Late \'e  stato principalmente introdotto per supportare la "dependency injection", ma pu\'o essere comunque utilizzato dal programmatore per scrivere codice efficiente
\end{itemize}





\subsection{Funzioni}
Le funzioni sono definite utilizzando la parola "fun" e il tipo di protezione di default associata alla funzione è quello "public", successivamente al nome della funzione verranno indicati i parametri opzionali e il valore di ritorno, qualora ci fosse.


\begin{lstlisting}[language=java,caption={Esempio Kotlin}]
fun saluta(nome: String): String {
  return "Ciao $nome"
}
\end{lstlisting}


Gli argomenti delle funzioni in Kotlin possono assumere il valore passato dal chiamante della funzione oppure avere un valore di default. Questa caratteristica oltre ad essere utile al programmatore che eviter\'a di inserire controlli all'interno di funzioni, o addirittura creare un'altra funzione con parametri diversi, aumenta la leggibilit\'a del codice, rendendolo pi\'u diretto e comprensivo.

\begin{lstlisting}[language=java,caption={Esempio Kotlin}]

fun buyItem(id:String, status: color = true){...}
buyItem(23)
\end{lstlisting}

\begin{lstlisting}[language=java,caption={Esempio Java}]
void buyItem(String id, Boolean color){...}
buyItem(23,true);

\end{lstlisting}

Kotlin prendendo spuntoo dalla programmazione funzionale introduce anche le seguenti caratteristiche:

\begin{itemize}                         %crea un elenco puntato

\item Funzioni alto ordine: sono funzioni che possono accettare come parametri altre funzioni, e restituire a loro volta funzioni

\item Assegnamento: \'e possibile assegnare ad una variale TODO()

\item TODO()
\begin{lstlisting}[language=java,caption={Esempio Kotlin}]

fun esempio(str: String, fn: (String) -> String): Unit {
  val prova = fn(str)
  println(prova)
}
\end{lstlisting}

\end{itemize}




\subsection{Data Classes}
Nella programmazione Android molto frequentemente vengono create classi per rappresentare modelli che verranno usati dall'applicazione, questi modelli devono contenere i metodi get e set per leggere e settare i valori di un oggetto.
Kotlin come Java \'e un linguaggio orientato agli oggetto, e per rendere meno verbosa la creazione di classi, introducente il marcatore "data" permettendo al programmatore di scrivere solamente il costruttore senza dover pensare alla creazione dei metodi get,set, equals,toString,hashCode tipicamente utilizzati nelle stesura di classi Java.
Questo rende il codice delle classi in Kotlin molto pi\'u coinciso e leggibile.

\begin{lstlisting}[language=java,caption={Esempio class Kotlin}]

data class User(val name: String, var password: String)
\end{lstlisting}

\begin{lstlisting}[language=java,caption={Esempio class Java}]

public class User {
 private String name;
 private String password;

 public User(String name, String password) {
  this.name = name;
  this.password = password;
 }
 public String getName() {
  return this.name;
  }
  public String getPassword() {
   return this.password;
   }

public void setName(String name) {
 this.name = name;
 }

 public void setPassword(String password) {
  this.password = password;
  }
    \end{lstlisting}


\subsection{Altro}
balblalbalba



\section{Section3}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra

\clearpage{\pagestyle{empty}\cleardoublepage}
