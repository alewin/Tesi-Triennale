\chapter{Kotlin}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}                  %mette i numeri arabi
\section{Storia}                 %crea la sezione

Kotlin \'e un linguaggio di programmazione open-source \footnote{https://github.com/JetBrains/kotlin}, con la caratteristica di essere orientato agli oggetti, staticamente tipizzato  e basato sulla JVM ( Java Virtual Machine). Lo sviluppo di Kotlin \'e iniziato nel 2010 dall'azienda JetBrains, conosciuta nel modo dello sviluppo software per la realizzazione di diversi IDE ( Integrated development environment ) , tra cui: Intellij IDEA sul quale si basa l'attuale IDE ufficiale di Google dedicato alla programmazione Android, chiamato: Android Studio. Java \'e attualmente uno dei linguaggii  pi\'u usato e conosciuto al mondo ma presenta diverse imperfezioni e problemi, che spinse il team di JetBrains a iniziare lo sviluppo di un suo linguaggio di programmazione che prendesse in considerazione, Caratteristiche di diversi linguaggi di programmazione preesistenti come CSharp, Scala, Groovy, Java e altri. Nel 2015 Google In 2015 Google prese in considerazione l'utilizzo di Kotlin come plugin per Android-Studio, e dopo vari test durante la conferenza Google IO ( 2017 ), venne annunciato Kotlin come linguaggio di programmazione ufficiale per lo sviluppo di applicazioni Android, senza escludere e rinunciare a Java.


\section{Caratteristiche}
Kotlin prendendo spunto da diversi linguaggi di programmazione imperativi e funzionali ha aggiunto diverse caratteristiche utili sia a livello sintattico che a livello prestazionale. \\
Le caratteristiche pi\'u importanti offerte da Kotlin sono l'interoperabilit\'a con Java, permettendo l'utilizzo di librerie Java e Kotlin simultaneamente, introduzione di alcune caratteristiche di linguaggi di ordine superiore, la tipizzazione statica delle variabili,il null-safety permettendo di differenziare il tipo nullabile e il tipo non-nullabile, prevenendo errori di null pointer expetions, \\
Il codice prodotto in Kotlin \`e inoltre pi\'u compatto, coninciso, permette di scrivere data-class senza dover indicare getters e setters, supporto delle lambda function Coroutines estensioni delle funzioni e molto altro

%allunga le Caratteristiche


%https://superkotlin.com/why-kotlin-is-the-best-language-for-android-development/
\subsection{Interoperabilit\'a}
I linguaggi Kotlin e Java sono intercompatibili permettendo quindi a entrambi i linguaggi di richimare funzioni e parti di codice in Java da Kotlin e viceversa, poich\'e entrambi i linguaggi producono Java Bytecode\\

%http://kotlinlang.org/docs/reference/java-interop.html

Prendiamo in considerazione il classico esempio "Hello word" scritto in Kotlin e in Java

\begin{lstlisting}[language=java,caption={Hello.kt in Kotlin}]
package demo
fun main(args : Array<String>) {
  println("Hello, world!")
}
\end{lstlisting}

\begin{lstlisting}[language=java,caption={Hello.java in Java}]

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
\end{lstlisting}

Il compilatore di Kotlin dando come input il file "Hello.kt" produrr\'a un JAR eseguibile da Java "Hello.jar"


\begin{lstlisting}[language=bash,caption={Compilatore kotlin}]
$ kotlinc Hello.kt -include-runtime -d Hello.jar
$ java -jar Hello.jar
$ Hello, world!
\end{lstlisting}
 -includeruntime \'e un opzione del compilatore per produrre un eseguibile jar, includendo le runtime di Kotlin (~800Kb)

Il compilatore di Kotlin permette inoltre di generare il java bytecode
\begin{lstlisting}[language=bash,caption={Compilatore kotlin per generare Hello.class}]
$ kotlinc HelloWorld.kt
$ javap -c Hello.class
\end{lstlisting}

% \begin{lstlisting}[language=java,caption={Java Bitecode generato da Kotlin}]
%
% public final class demo.HelloKt {
%   public static final void main(java.lang.String[]);
%     Code:
%        0: aload_0
%        1: ldc           #9                  // String args
%        3: invokestatic  #15                 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V
%        6: ldc           #17                 // String Hello, world!
%        8: astore_1
%        9: getstatic     #23                 // Field java/lang/System.out:Ljava/io/PrintStream;
%       12: aload_1
%       13: invokevirtual #29                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
%       16: return
% }
%
% \end{lstlisting}


% \begin{lstlisting}[language=java,caption={Java Bitecode generato da Kotlin}]
%
% class Hello {
%   Hello();
%     Code:
%        0: aload_0
%        1: invokespecial #1                  // Method java/lang/Object."<init>":()V
%        4: return
%
%   public static void main(java.lang.String[]);
%     Code:
%        0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
%        3: ldc           #3                  // String Hello, world!
%        5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
%        8: return
% }
%
%
% \end{lstlisting}


Oltre ad alcune aggiunte di Kotlin il bytecode generato dal compilatore Kotlin \'e molto simile a quello generato da Java, successivamente verranno analizzate
funzioni e parti di codice pi\'u complesse per evidenziare alcune modifiche apportate da kotlin nella compilazione del jar per ottimizzare o gestire nuove funzionalit\'a.\\
Un altro esempio utile per capire meglio l'interoperabilit\'a di Kotlin \'e il seguente


\begin{lstlisting}[language=java,caption={Esempio}]

import java.util.Calendar

fun calendarDemo() {
    val calendar = Calendar.getInstance()
    if (calendar.firstDayOfWeek == Calendar.SUNDAY) {  // call getFirstDayOfWeek()
        calendar.firstDayOfWeek = Calendar.MONDAY       // call setFirstDayOfWeek()
    }
}
\end{lstlisting}


\subsection{Variabili}
Java pone due differenze quando si parla di variabili, mette a disposizione i principali tipi primitivi (int, boolean, byte, long, short, float, double, char) e i le loro corrispondenti classi (Int, Boolean, Byte, Long, Short, Float, Double, Char)
Uno dei principali cambiamenti introdotti da Kotlin \'e stato quello di definire tutte le varibili come se fossero un oggetto.\\
%https://docs.oracle.com/javase/1.5.0/docs/guide/language/autoboxing.html
La differenza fra i tipi primitivi e gli offetti sta nel fatto che i primi indicano solamente il tipo di una variabile, mentre gli offetti incapsulano il tipo e ne aggiungono funzionalit\'a e metodi aggiuntivi, inoltre il tipo primitivo non pu\'o assumere valore nullo. \\
Kotlin rimuove le due distinzioni, ma solo ad alto livello, poich\'e di default quando viene inizializzata una nuova variabile utilizza gli oggetti, e in fase di compilazione controlla se l'oggetto \'e strettamente necessario o pu\'d essere sostituito dal suo corrispondente tipo primivio.

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
    Tipo & Oggetto & Dimensione \\ \hline
    int & Int & 32 bits\\ \hline
    boolean & Boolean & 1 bits\\ \hline
    byte & Byte & 8 bits\\ \hline
    long & Long & 64 bits\\ \hline
    short & Short & 16 bits\\ \hline
    float & Float & 32 bits\\ \hline
    double & Double & 64 bits\\ \hline
    char & Char & 16 bits\\ \hline

    \end{tabular}
\end{center}

Le variabili in Kotlin sono pressocc\'e le stesse che sono presenti in Java, con la particolari\'a
che Kotlin cerca di evitare alcuni problemi dovuti a referenze a puntatori nullabile ( NullPointerException ). \\
Kotlin richiede che una variabile a cui assegnamo un valore nullo sia dichiarata con il simbolo "?", in caso contrario mostrera un errore in fase di compilazione

\begin{lstlisting}[language=java,caption={Esempio}]
var esempio1: String? = null //corretto
var esempio2: String = null //errore
\end{lstlisting}

Il simbolo "?" serve ad indicare che la variabile pu\'o assumere un valore nullo, e lascia al programmatore la possibilit\'a di accederci ugualmente per saperne il valore, con l'utilizzo il simbolo "!!"",


\begin{lstlisting}[language=java,caption={Esempio !!}]
val nome = getName()!!
\end{lstlisting}

in altrnativa attraverso il Smart Casting offerto da Kotlin il simbolo "!!" si pu\'o omettere, poich\'e il compilatore capisce automaticamente che la variabile non potr\'a essere nulla.

\begin{lstlisting}[language=java,caption={Smart Casting}]
fun getName(): String? {..}

val name = getName()
if (name != null) {
  println(name.length)
}

//forma contratta
println(name?.length)
\end{lstlisting}

Un'ultima caratteristica introdotta da Kotlin nell'utilizzo e gestione delle variabili sono  "Lazy  Initialization " e "Late Initialization", due modi per inizializzre una variabile.
\begin{itemize}                         %crea un elenco puntato
\item Lazy consente di delegare ad una funzione l'inizializzazione della variabile, e il risultato della funzione verr\'a assegnato alla variabile, in seguito quando verr\'a effettuato l'accesso alla variabile la funzione non sar\'a rieseguita ma verr\'a solamente passato il valore
\item Late permette di posticipare l'inizializzazione di una variabile, se si tenter\'a di acceddere alla variabile prima che essa venga inizializzata si ricever\'a un errore. Late è stato principalmente introdotto per supportare la "dependency injection", ma pu\'o essere comunque utilizzato dal programmatore per scrivere codice efficiente
\end{itemize}





\subsection{Funzioni}
Le funzioni sono definite utilizzando la parola "fun" e il tipo di protezione associato alla funzione, quello di default è public; successivamente verranno indicati i parametri opzionali e il valore di ritorno


\begin{lstlisting}[language=java,caption={Esempio Kotlin}]
fun saluta(nome: String): String {
  return "Ciao $nome"
}
\end{lstlisting}


Gli argomenti delle funzioni in Kotlin possono assumere il valore passato dal chiamante della
funzione oppure avere un valore di default. Questa caratteristica oltre ad essere utile al programmatore
che evita di inserire controlli all'interno di funzioni, o addirittura creare un'altra funzione con parametri diversi, aumenta la leggibilit\'a del codice.

\begin{lstlisting}[language=java,caption={Esempio Kotlin}]

fun buyItem(id:String, status: color = true){...}
buyItem(23)
\end{lstlisting}

\begin{lstlisting}[language=java,caption={Esempio Java}]
void buyItem(String id, Boolean color){...}
buyItem(23,true);

\end{lstlisting}



Kotlin prendendo spuntoo dalla programmazione funzionale introduce le seguenti caratteristiche:


\begin{itemize}                         %crea un elenco puntato

\item Funzioni alto ordine: sono funzioni che possono accettare come parametri altre funzioni, e restituire a loro volta funzioni

\item Assegnamento: è possibile assegnare ad una


\begin{lstlisting}[language=java,caption={Esempio Kotlin}]

fun esempio(str: String, fn: (String) -> String): Unit {
  val prova = fn(str)
  println(prova)
}
\end{lstlisting}




\end{itemize}




\subsection{Data Classes}
Kotlin come Java \'e un linguaggio orientato agli oggetto.Nella programmazione Android molto frequentemente vengono create classi per rappresentare modelli che verranno usati dall'applicazione, questi modelli devono contenere i metodi get e set per leggere e settare i valori di un oggetto.
Kotlin introducente il marcatore "data" permettendo al programmatore di scrivere solamente il costruttore senza dover pensare alla creazione dei metodi get,set, equals,toString,hashCode tipicamente utilizzati nelle stesura di classi Java.
Questa semplice introduzione, il codice delle classi in Kotlin risulta essere molto pi\'u coinciso e leggibile.

\begin{lstlisting}[language=java,caption={Esempio class Kotlin}]

data class User(val name: String, var password: String)
\end{lstlisting}

\begin{lstlisting}[language=java,caption={Esempio class Java}]

public class User {
 private String name;
 private String password;

 public User(String name, String password) {
  this.name = name;
  this.password = password;
 }
 public String getName() {
  return this.name;
  }
  public String getPassword() {
   return this.password;
   }

public void setName(String name) {
 this.name = name;
 }

 public void setPassword(String password) {
  this.password = password;
  }
    \end{lstlisting}


\subsection{Altro}
balblalbalba



\section{Data Classes}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra

\clearpage{\pagestyle{empty}\cleardoublepage}
